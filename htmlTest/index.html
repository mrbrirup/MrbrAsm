<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mrbr Test</title>
    <!-- <script src="../dist/min/mrbr.min.js"></script> -->
    <style>
        html,
        body {
            height: 100vh;
            width: 100vw;
        }
    </style>
    <!-- <script src="../dist/min/mrbr.min.js"></script> -->
    <script src="../dist/asm/mrbr.js"></script>
    <script data-path-mrbr="../dist/asm" src="./scripts/initTest.js"></script>
    <link href="./style/mrbrDialog.css" rel="stylesheet" type="text/css">
    <link href="./style/mrbrDefaults.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.9.1/font/bootstrap-icons.css">
    <style>
        @keyframes FadeIn {
            0% {
                opacity: 0;
            }

            100% {
                opacity: 1;
            }
        }

        .mrbr_fadeIn {
            animation-name: FadeIn;
            animation-duration: 1s;
            transition-timing-function: ease-in;
        }
    </style>
    <script>
        class MrbrAssembly extends Map {
            static MRBR_ASSEMBLY_NAMESPACE = Symbol("__ma_namespace__");
            static MRBR_ASSEMBLY_SIZE = Symbol("__ma_namespace__size__");
            static MRBR_ASSEMBLY_TARGET = Symbol("__ma_namespace__target__");
            static MRBR_ASSEMBLY_NAME = Symbol("__ma_namespace__name__");
            static MRBR_ASSEMBLY_PARENT = Symbol("__ma_namespace__parent__");
            static MRBR_ASSEMBLY_TO_STRING = Symbol("__ma_namespace__tostring__");
            constructor(parent, name) {
                super()
                const self = this;
                self[MrbrAssembly.MRBR_ASSEMBLY_PARENT] = parent;
                self[MrbrAssembly.MRBR_ASSEMBLY_NAME] = name;
                self[MrbrAssembly.MRBR_ASSEMBLY_NAMESPACE] = true;
                return new Proxy(this, MrbrAssembly.PROXY_HANDLER);
            }
            static PROXY_HANDLER = {
                get(target, name) {
                    switch (name) {
                        case MrbrAssembly.MRBR_ASSEMBLY_NAMESPACE: return target[MrbrAssembly.MRBR_ASSEMBLY_NAMESPACE];
                        case MrbrAssembly.MRBR_ASSEMBLY_SIZE: return target.size;
                        case MrbrAssembly.MRBR_ASSEMBLY_TARGET: return target;
                        case MrbrAssembly.MRBR_ASSEMBLY_NAME: return target[MrbrAssembly.MRBR_ASSEMBLY_NAME];
                        case MrbrAssembly.MRBR_ASSEMBLY_PARENT: return target[MrbrAssembly.MRBR_ASSEMBLY_PARENT];
                        case MrbrAssembly.MRBR_ASSEMBLY_TO_STRING: {
                            let namespace = [target[MrbrAssembly.MRBR_ASSEMBLY_NAME]]
                            let parent = target[MrbrAssembly.MRBR_ASSEMBLY_PARENT];
                            if (parent) { namespace.push(parent[MrbrAssembly.MRBR_ASSEMBLY_NAME]) }
                            while (parent) {
                                parent = parent[MrbrAssembly.MRBR_ASSEMBLY_PARENT];
                                if (parent) { namespace.push(parent[MrbrAssembly.MRBR_ASSEMBLY_NAME]) }
                            }
                            return namespace.reverse().join(".");
                        }
                        default:
                            if (target.has(name) === false) {
                                target.set(name, new MrbrAssembly(target, name))
                            }
                    }
                    return (target.has(name)) ? (target.get(name)) : null;
                },
                set(target, name, value) {
                    if (name === MrbrAssembly.MRBR_ASSEMBLY_NAME ||
                        name === MrbrAssembly.MRBR_ASSEMBLY_NAMESPACE ||
                        name === MrbrAssembly.MRBR_ASSEMBLY_PARENT) {
                        return target
                    }
                    else if (target[MrbrAssembly.MRBR_ASSEMBLY_SIZE] === 0 &&
                        target[MrbrAssembly.MRBR_ASSEMBLY_NAMESPACE] === true) {
                        target.set(name, value);
                        return target;
                    }
                    let namedTarget = target.get(name);
                    if (
                        !namedTarget ||
                        (namedTarget instanceof Map === false) ||
                        (namedTarget instanceof Map &&
                            namedTarget[MrbrAssembly.MRBR_ASSEMBLY_NAMESPACE] === false) ||
                        (namedTarget instanceof Map &&
                            namedTarget[MrbrAssembly.MRBR_ASSEMBLY_SIZE] === 0 &&
                            namedTarget[MrbrAssembly.MRBR_ASSEMBLY_NAMESPACE] === true)) {
                        target.set(name, value);
                        return target;
                    }
                    if (namedTarget instanceof Map &&
                        namedTarget[MrbrAssembly.MRBR_ASSEMBLY_SIZE] > 0 &&
                        namedTarget[MrbrAssembly.MRBR_ASSEMBLY_NAMESPACE] === true) {
                        throw new Error(`${namedTarget[MrbrAssembly.MRBR_ASSEMBLY_NAME]} is not an empty Namespace`);
                    }
                }
            }
            static createAssembly(parent, name){
                parent[name] = new MrbrAssembly(parent,name);
                return parent[name];
            }
        }
        MrbrAssembly.createAssembly(window, "Mrbr");
    </script>
</head>

<body>
</body>

</html>